{"meta":{"title":"Autumn Night's Blog","subtitle":null,"description":"无所求则无所获。","author":"秋枫夜","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-03-23T09:21:03.000Z","updated":"2018-03-23T10:07:02.160Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-03-23T09:37:23.000Z","updated":"2018-03-23T09:37:23.877Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-03-23T09:11:57.000Z","updated":"2018-03-23T09:20:10.106Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序算法（一）","slug":"常用排序算法","date":"2018-03-26T05:44:09.000Z","updated":"2018-03-26T05:50:01.511Z","comments":true,"path":"2018/03/26/常用排序算法/","link":"","permalink":"http://yoursite.com/2018/03/26/常用排序算法/","excerpt":"1. 算法的特征 有穷性：算法的每个步骤都能在有限时间内完成 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。 2.算法的设计原则 正确性 可读性 健壮性 高效率与低存储","text":"1. 算法的特征 有穷性：算法的每个步骤都能在有限时间内完成 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。 2.算法的设计原则 正确性 可读性 健壮性 高效率与低存储 3.常用排序算法1.冒泡排序 比较相邻的元素，第一个比第二个大，交换两个的位置 对每一对相邻的元素作同样的工作，从开始第一队到结尾最后一对，最后元素最大的会到末尾 重复上述步骤 直到没有比较元素 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; int[] arr = &#123;8, 4, 3, 2, 9, 7, 4, 6, 2&#125;; System.out.print(&quot;原数组：&quot;); display(arr); System.out.println(&quot;***************************&quot;); moSort(arr); &#125; /** * 冒泡排序 * * @param array */ public static int[] moSort(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; boolean flag = true; for (int j = 0; j &lt; array.length - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; System.out.print(&quot;第&quot; + i + &quot;轮排序后的结果为:&quot;); display(array); &#125; return array; &#125; public static void display(int[] arry) &#123; for (int i = 0; i &lt; arry.length; i++) &#123; System.out.print(arry[i] + &quot; &quot;); &#125; System.out.println(); &#125; 2.选择排序 从待排序序列中，找到关键字最小的元素 如果最小元素不是待排序的第一个元素，将其和第一个元素互换 从余下的N-1个元素中，找出最小的元素，重复1,2 选择排序和冒泡排序执行了相同次数比较 N*(N-1)/2,至多进行N次交换 当N值很大时，比较次数是主要的，由于选择排序交换次数少，所以比冒泡排序快。 12345678910111213141516171819202122232425262728293031/** * 选择排序 * * @param arr * @return */ public static int[] choiceSort(int[] arr) &#123; //总共需要N-1轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; //每轮需要比较的次数 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; //记录目前能找到最小值元素下标 min = j; &#125; if (i != min) &#123; int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; System.out.print(&quot;第&quot; + i + &quot;轮排序后的结果为:&quot;); display(arr); &#125; return arr; &#125; 3.插入排序 每一步都将待排序的元素插入到前面已经排序好的序列中 1234567891011121314151617181920212223242526/** * 插入排序 * @param arr */ public static int[] InsertSort(int[] arr)&#123; int j; //从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt;arr.length ; i++) &#123; //记录要插入的数据 int temp = arr[i]; j = i; //从已经排序的序列最右边开始比较，找到比其小的数 while(j&gt;0 &amp;&amp; temp&lt;arr[j-1])&#123; //向后挪动 arr[j] = arr[j-1]; j--; &#125; //存在比起晓得数插入 arr[j] = temp; System.out.print(&quot;第&quot; + i + &quot;轮排序后的结果为:&quot;); display(arr); &#125; return arr; &#125; 4.总结 上面讲的三种排序，冒泡、选择、插入用大 O 表示法都需要 O(N2) 时间级别。一般不会选择冒泡排序，虽然冒泡排序书写是最简单的，但是平均性能是没有选择排序和插入排序好的。 选择排序把交换次数降低到最低，但是比较次数还是挺大的。当数据量小，并且交换数据相对于比较数据更加耗时的情况下，可以应用选择排序。 在大多数情况下，假设数据量比较小或基本有序时，插入排序是三种算法中最好的选择。","categories":[{"name":"Java算法","slug":"Java算法","permalink":"http://yoursite.com/categories/Java算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"Java设计模式-观察者模式","slug":"Java设计模式-观察者模式","date":"2018-03-26T01:23:41.000Z","updated":"2018-03-26T05:35:38.208Z","comments":true,"path":"2018/03/26/Java设计模式-观察者模式/","link":"","permalink":"http://yoursite.com/2018/03/26/Java设计模式-观察者模式/","excerpt":"一、观察者模式定义 在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的：观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 特点 被观察者需要持有一个或者多个被观察者对象 系统中某一个模块发生变化，某些模块也会发生改变 UML 观察者模式涉及到的角色 抽象被观察者角色：定义了动态增加、删除及通知观察者对象的方法，职责就是管理和通知观察者。持有观察者对象的集合 具体被观察者：一般继承抽象观察者，实现自己本身的业务逻辑，当状态发生改变是发起通知。 抽象观察者角色：提供一个接口，定义了观察者收到通知更新自己的方法 具体观察者角色：实现抽象观察者接口，处理不同具体观察者的不同逻辑","text":"一、观察者模式定义 在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的：观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 特点 被观察者需要持有一个或者多个被观察者对象 系统中某一个模块发生变化，某些模块也会发生改变 UML 观察者模式涉及到的角色 抽象被观察者角色：定义了动态增加、删除及通知观察者对象的方法，职责就是管理和通知观察者。持有观察者对象的集合 具体被观察者：一般继承抽象观察者，实现自己本身的业务逻辑，当状态发生改变是发起通知。 抽象观察者角色：提供一个接口，定义了观察者收到通知更新自己的方法 具体观察者角色：实现抽象观察者接口，处理不同具体观察者的不同逻辑 二、实例羊具有被观察者属性，狼是观察者。 抽象被观察123456789101112131415161718192021222324252627282930public abstract class Subject &#123; private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); /** * 登记观察者 * @param observer */ public void attach(Observer observer)&#123; observerList.add(observer); System.out.println(&quot;增加观察者：&quot; + observer.getName()); &#125; /** * 删除观察者 * @param observer */ public void dettach(Observer observer)&#123; observerList.remove(observer); System.out.println(&quot;删除了观察者：&quot;+observer.getName()); &#125; /** * 通知所有观察者 */ public void notifyOberver()&#123; for (Observer observer : observerList) &#123; observer.update(&quot;羊出来活动了&quot;); &#125; &#125;&#125; 具体被观察者12345678910public class WhiteSheep extends Subject &#123; /** * 羊活动 */ public void activity()&#123; System.out.println(&quot;羊出来活动了&quot;); notifyOberver(); &#125;&#125; 抽象观察者角色123456789101112131415public interface Observer &#123; /** * 观察者名称 * @return */ String getName(); /** * 通知更新方法 * @param msg 信息 */ public void update(String msg);&#125; 具体观察者角色1234567891011public class BlackWolf implements Observer &#123; @Override public String getName() &#123; return &quot;黑狼&quot;; &#125; @Override public void update(String msg) &#123; System.out.println(&quot;黑狼收到通知：&quot;+msg); &#125;&#125; 运行12345678910public static void main(String[] args) &#123; WhiteSheep whiteSheep = new WhiteSheep(); Observer blackWolf = new BlackWolf(); Observer redWolf = new RedWolf(); //增加观察者 whiteSheep.attach(blackWolf); whiteSheep.attach(redWolf); //羊出来活动 whiteSheep.activity(); &#125; 运行结果12345增加观察者：黑狼增加观察者：红狼羊出来活动了黑狼收到通知：羊出来活动了红狼收到通知：羊出来活动了 三、Java提供的对观察者模式的支持在java语言中java.utils库里面，提供了一个Observable类以及一个Observer接口，构成java语言对观察者模式的支持。 Observable类被观察者都是java.utils.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs = new Vector(); public Observable() &#123; &#125; /** *将观察者添加到观察者集合里 **/ public synchronized void addObserver(Observer var1) &#123; if(var1 == null) &#123; throw new NullPointerException(); &#125; else &#123; if(!this.obs.contains(var1)) &#123; this.obs.addElement(var1); &#125; &#125; &#125; /** * 删除观察者 **/ public synchronized void deleteObserver(Observer var1) &#123; this.obs.removeElement(var1); &#125; public void notifyObservers() &#123; this.notifyObservers((Object)null); &#125; /** *通知更新 **/ public void notifyObservers(Object var1) &#123; Object[] var2; synchronized(this) &#123; if(!this.changed) &#123; return; &#125; var2 = this.obs.toArray(); this.clearChanged(); &#125; for(int var3 = var2.length - 1; var3 &gt;= 0; --var3) &#123; ((Observer)var2[var3]).update(this, var1); &#125; &#125; public synchronized void deleteObservers() &#123; this.obs.removeAllElements(); &#125; protected synchronized void setChanged() &#123; this.changed = true; &#125; protected synchronized void clearChanged() &#123; this.changed = false; &#125; public synchronized boolean hasChanged() &#123; return this.changed; &#125; public synchronized int countObservers() &#123; return this.obs.size(); &#125;&#125; Observer接口这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 123public interface Observer &#123; void update(Observable var1, Object var2);&#125; 四、Java中观察者模式的使用在这个例子中，被观察对象叫做Watched；而观察者对象叫做Watcher。Watched对象继承自java.util.Observable类；而Watcher对象实现了java.util.Observer接口。另外有一个Test类扮演客户端角色。 Watched 继承 Observable 1234567891011121314151617public class Watched extends Observable&#123; private String data = &quot;&quot;; public String getData() &#123; return data; &#125; public void setData(String data) &#123; if(!this.data.equals(data))&#123; this.data = data; setChanged(); &#125; notifyObservers(this); &#125;&#125; Watcher 实现 Observer接口重写update方法 12345678910111213public class Watcher implements Observer&#123; public Watcher(Observable o)&#123; o.addObserver(this); &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(&quot;状态发生改变：&quot; + ((Watched)o).getData()); &#125;&#125; 测试 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; //创建被观察者对象 Watched watched = new Watched(); //创建观察者对象，并将被观察者对象登记 Observer watcher = new Watcher(watched); //给被观察者状态赋值 watched.setData(&quot;start&quot;); watched.setData(&quot;run&quot;); watched.setData(&quot;stop&quot;); &#125;&#125; 五、观察者模式优缺点1.优点 观察者和被观察者之间抽象耦合。观察者模式容易扩展，被观察者只持有观察者集合，并不需要知道具体观察者内部的实现。 对象之间的保持高度的协作。当被观察者发生变化时，所有被观察者都会通知到，然后做出相应的动作。 2.缺点 如果观察者太多，被观察者通知观察者消耗的时间很多，影响系统的性能。 当观察者集合中的某一观察者错误时就会导致系统卡壳，因此一般会采用异步方式。 文章主要收集自我的Java设计模式-观察者模式，《JAVA与模式》之观察者模式","categories":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://yoursite.com/categories/Java设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Github Pages搭建遇到的问题","slug":"Github-Pages搭建遇到的问题","date":"2018-03-23T09:45:39.000Z","updated":"2018-03-23T09:59:19.668Z","comments":true,"path":"2018/03/23/Github-Pages搭建遇到的问题/","link":"","permalink":"http://yoursite.com/2018/03/23/Github-Pages搭建遇到的问题/","excerpt":"","text":"1.hexo -d 上传不了GitHub12345678910修改配置文件：根目录下的_config.yml，修改deploy节点。原来的配置为：deploy: type: git repo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master修改为如下：deploy: type: git repo: https://&#123;yourname&#125;:&#123;yourpassword&#125;@github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master","categories":[{"name":"问题","slug":"问题","permalink":"http://yoursite.com/categories/问题/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}]}