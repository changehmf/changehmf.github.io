{"meta":{"title":"Autumn Night's Blog","subtitle":null,"description":"无所求则无所获。","author":"秋枫夜","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-03-23T09:37:23.000Z","updated":"2018-03-23T09:37:23.877Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-03-23T09:21:03.000Z","updated":"2018-03-23T10:07:02.160Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-03-23T09:11:57.000Z","updated":"2018-03-23T09:20:10.106Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java设计模式-观察者模式","slug":"Java设计模式-观察者模式","date":"2018-03-26T01:23:41.000Z","updated":"2018-03-26T04:35:14.431Z","comments":true,"path":"2018/03/26/Java设计模式-观察者模式/","link":"","permalink":"http://yoursite.com/2018/03/26/Java设计模式-观察者模式/","excerpt":"Java设计模式-观察者模式一、观察者模式定义 在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的：观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 特点 被观察者需要持有一个或者多个被观察者对象 系统中某一个模块发生变化，某些模块也会发生改变 UML 观察者模式涉及到的角色 抽象被观察者角色：定义了动态增加、删除及通知观察者对象的方法，职责就是管理和通知观察者。持有观察者对象的集合 具体被观察者：一般继承抽象观察者，实现自己本身的业务逻辑，当状态发生改变是发起通知。 抽象观察者角色：提供一个接口，定义了观察者收到通知更新自己的方法 具体观察者角色：实现抽象观察者接口，处理不同具体观察者的不同逻辑","text":"Java设计模式-观察者模式一、观察者模式定义 在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的：观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 特点 被观察者需要持有一个或者多个被观察者对象 系统中某一个模块发生变化，某些模块也会发生改变 UML 观察者模式涉及到的角色 抽象被观察者角色：定义了动态增加、删除及通知观察者对象的方法，职责就是管理和通知观察者。持有观察者对象的集合 具体被观察者：一般继承抽象观察者，实现自己本身的业务逻辑，当状态发生改变是发起通知。 抽象观察者角色：提供一个接口，定义了观察者收到通知更新自己的方法 具体观察者角色：实现抽象观察者接口，处理不同具体观察者的不同逻辑 二、实例羊具有被观察者属性，狼是观察者。 抽象被观察 123456789101112131415161718192021222324252627282930public abstract class Subject &#123; private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); /** * 登记观察者 * @param observer */ public void attach(Observer observer)&#123; observerList.add(observer); System.out.println(&quot;增加观察者：&quot; + observer.getName()); &#125; /** * 删除观察者 * @param observer */ public void dettach(Observer observer)&#123; observerList.remove(observer); System.out.println(&quot;删除了观察者：&quot;+observer.getName()); &#125; /** * 通知所有观察者 */ public void notifyOberver()&#123; for (Observer observer : observerList) &#123; observer.update(&quot;羊出来活动了&quot;); &#125; &#125;&#125; 具体被观察者 12345678910public class WhiteSheep extends Subject &#123; /** * 羊活动 */ public void activity()&#123; System.out.println(&quot;羊出来活动了&quot;); notifyOberver(); &#125;&#125; 抽象观察者角色 123456789101112131415public interface Observer &#123; /** * 观察者名称 * @return */ String getName(); /** * 通知更新方法 * @param msg 信息 */ public void update(String msg);&#125; 具体观察者角色 1234567891011public class BlackWolf implements Observer &#123; @Override public String getName() &#123; return &quot;黑狼&quot;; &#125; @Override public void update(String msg) &#123; System.out.println(&quot;黑狼收到通知：&quot;+msg); &#125;&#125; 运行 12345678910public static void main(String[] args) &#123; WhiteSheep whiteSheep = new WhiteSheep(); Observer blackWolf = new BlackWolf(); Observer redWolf = new RedWolf(); //增加观察者 whiteSheep.attach(blackWolf); whiteSheep.attach(redWolf); //羊出来活动 whiteSheep.activity(); &#125; 运行结果 12345增加观察者：黑狼增加观察者：红狼羊出来活动了黑狼收到通知：羊出来活动了红狼收到通知：羊出来活动了 三、Java提供的对观察者模式的支持在java语言中java.utils库里面，提供了一个Observable类以及一个Observer接口，构成java语言对观察者模式的支持。 Observable类被观察者都死java.utils.Observable类的子类。ava.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs = new Vector(); public Observable() &#123; &#125; /** *将观察者添加到观察者集合里 **/ public synchronized void addObserver(Observer var1) &#123; if(var1 == null) &#123; throw new NullPointerException(); &#125; else &#123; if(!this.obs.contains(var1)) &#123; this.obs.addElement(var1); &#125; &#125; &#125; /** * 删除观察者 **/ public synchronized void deleteObserver(Observer var1) &#123; this.obs.removeElement(var1); &#125; public void notifyObservers() &#123; this.notifyObservers((Object)null); &#125; /** *通知更新 **/ public void notifyObservers(Object var1) &#123; Object[] var2; synchronized(this) &#123; if(!this.changed) &#123; return; &#125; var2 = this.obs.toArray(); this.clearChanged(); &#125; for(int var3 = var2.length - 1; var3 &gt;= 0; --var3) &#123; ((Observer)var2[var3]).update(this, var1); &#125; &#125; public synchronized void deleteObservers() &#123; this.obs.removeAllElements(); &#125; protected synchronized void setChanged() &#123; this.changed = true; &#125; protected synchronized void clearChanged() &#123; this.changed = false; &#125; public synchronized boolean hasChanged() &#123; return this.changed; &#125; public synchronized int countObservers() &#123; return this.obs.size(); &#125;&#125; Observer接口这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 123public interface Observer &#123; void update(Observable var1, Object var2);&#125; 四、Java中观察者模式的使用在这个例子中，被观察对象叫做Watched；而观察者对象叫做Watcher。Watched对象继承自java.util.Observable类；而Watcher对象实现了java.util.Observer接口。另外有一个Test类扮演客户端角色。 Watched 继承 Observable 1234567891011121314151617public class Watched extends Observable&#123; private String data = &quot;&quot;; public String getData() &#123; return data; &#125; public void setData(String data) &#123; if(!this.data.equals(data))&#123; this.data = data; setChanged(); &#125; notifyObservers(this); &#125;&#125; Watcher 实现 Observer接口重写update方法 12345678910111213public class Watcher implements Observer&#123; public Watcher(Observable o)&#123; o.addObserver(this); &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(&quot;状态发生改变：&quot; + ((Watched)o).getData()); &#125;&#125; 测试 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; //创建被观察者对象 Watched watched = new Watched(); //创建观察者对象，并将被观察者对象登记 Observer watcher = new Watcher(watched); //给被观察者状态赋值 watched.setData(&quot;start&quot;); watched.setData(&quot;run&quot;); watched.setData(&quot;stop&quot;); &#125;&#125; 五、观察者模式优缺点1.优点 观察者和被观察者之间抽象耦合。观察者模式容易扩展，被观察者只持有观察者集合，并不需要知道具体观察者内部的实现。 对象之间的保持高度的协作。当被观察者发生变化时，所有被观察者都会通知到，然后做出相应的动作。2.缺点 如果观察者太多，被观察者通知观察者消耗的时间很多，影响系统的性能。 当观察者集合中的某一观察者错误时就会导致系统卡壳，因此一般会采用异步方式。 文章主要收集自我的Java设计模式-观察者模式，《JAVA与模式》之观察者模式","categories":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"http://yoursite.com/categories/Java设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Github Pages搭建遇到的问题","slug":"Github-Pages搭建遇到的问题","date":"2018-03-23T09:45:39.000Z","updated":"2018-03-23T09:59:19.668Z","comments":true,"path":"2018/03/23/Github-Pages搭建遇到的问题/","link":"","permalink":"http://yoursite.com/2018/03/23/Github-Pages搭建遇到的问题/","excerpt":"","text":"1.hexo -d 上传不了GitHub12345678910修改配置文件：根目录下的_config.yml，修改deploy节点。原来的配置为：deploy: type: git repo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master修改为如下：deploy: type: git repo: https://&#123;yourname&#125;:&#123;yourpassword&#125;@github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master","categories":[{"name":"问题","slug":"问题","permalink":"http://yoursite.com/categories/问题/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}]}